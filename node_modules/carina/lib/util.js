"use strict";
var errors_1 = require('./errors');
/**
 * Returns a promise that's resolved when an event is emitted on the
 * EventEmitter.
 * @param  {EventEmitter} emitter
 * @param  {string}       event
 * @para   {number}       timeout used to prevent memory leaks
 * @return {Promise<any>}
 */
function resolveOn(emitter, event, timeout) {
    if (timeout === void 0) { timeout = 120 * 1000; }
    return new Promise(function (resolve, reject) {
        var resolved = false;
        var listener = function (data) {
            resolved = true;
            resolve(data);
        };
        emitter.once(event, listener);
        setTimeout(function () {
            if (!resolved) {
                emitter.removeListener(event, listener);
                reject(new errors_1.TimeoutError("Expected to get event " + event));
            }
        }, timeout);
    });
}
exports.resolveOn = resolveOn;
/**
 * Return a promise which is rejected with a TimeoutError after the
 * provided delay.
 * @param  {Number} delay
 * @return {Promise}
 */
function timeout(message, delay) {
    // Capture the stacktrace here, since timeout stacktraces
    // often get mangled or dropped.
    var err = new errors_1.TimeoutError(message);
    return new Promise(function (resolve, reject) {
        setTimeout(function () { return reject(err); }, delay);
    });
}
exports.timeout = timeout;
//# sourceMappingURL=util.js.map