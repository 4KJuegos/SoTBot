"use strict";
var socket_1 = require('./socket');
var Carina = (function () {
    function Carina(options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.waiting = {};
        this.subscriptions = [];
        this.socket = new socket_1.ConstellationSocket(options);
        // Resub to live events on reconnect.
        this.socket.on('open', function () {
            if (_this.subscriptions.length > 0) {
                _this.socket.execute('livesubscribe', { events: _this.subscriptions });
            }
        });
    }
    Object.defineProperty(Carina, "WebSocket", {
        get: function () {
            return socket_1.ConstellationSocket.WebSocket;
        },
        /**
         * Set the websocket implementation.
         * You will likely not need to set this in a browser environment.
         * You will not need to set this if WebSocket is globally available.
         *
         * @example
         * Carina.WebSocket = require('ws');
         */
        set: function (ws) {
            socket_1.ConstellationSocket.WebSocket = ws;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the given options on the socket.
     */
    Carina.prototype.setOptions = function (options) {
        this.socket.setOptions(options);
    };
    /**
     * Boots the connection to constellation.
     */
    Carina.prototype.open = function () {
        this.socket.connect();
        return this;
    };
    /**
     * Frees resources associated with the Constellation connection.
     */
    Carina.prototype.close = function () {
        this.socket.close();
    };
    /**
     * @callback onSubscriptionCb
     * @param {Object} data - The payload for the update.
     */
    /**
     * Subscribe to a live event
     *
     * @param {string} slug
     * @param {onSubscriptionCb} cb - Called each time we receive an event for this slug.
     * @returns {Promise.<>} Resolves once subscribed. Any errors will reject.
     */
    Carina.prototype.subscribe = function (slug, cb) {
        var _this = this;
        this.socket.on('event:live', function (data) {
            if (data.channel === slug) {
                cb(data.payload);
            }
        });
        return this
            .waitFor("subscription:" + slug, function () {
            return _this.socket.execute('livesubscribe', { events: [slug] })
                .then(function (res) {
                _this.subscriptions.push(slug);
                return res;
            });
        })
            .catch(function (err) {
            _this.stopWaiting("subscription:" + slug);
            throw err;
        });
    };
    /**
     * Unsubscribe from a live event.
     *
     * @param {string} slug
     * @returns {Promise.<>} Resolves once unsubscribed. Any errors will reject.
     */
    Carina.prototype.unsubscribe = function (slug) {
        var _this = this;
        this.stopWaiting("subscription:" + slug);
        return this.socket.execute('liveunsubscribe', { events: [slug] })
            .then(function (res) {
            var index = _this.subscriptions.indexOf(slug);
            if (index > -1) {
                _this.subscriptions.splice(index, 1);
            }
            return res;
        });
    };
    Carina.prototype.waitFor = function (identifier, cb) {
        if (this.waiting[identifier]) {
            return this.waiting[identifier];
        }
        return this.waiting[identifier] = cb();
    };
    Carina.prototype.stopWaiting = function (identifier) {
        delete this.waiting[identifier];
    };
    return Carina;
}());
exports.Carina = Carina;
//# sourceMappingURL=carina.js.map